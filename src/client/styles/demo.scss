@charset "utf-8";

//ONLY OK EXAMPLES BELOW

//quotation
$direction: 'left';//text
$font-type: sans-serif;//identifier(unquoted)
$font-type: unquote('sans-serif');
$length: 0;

$value: 42;
$length: $value * 1px;//to obtain 42, in px
$value: ($length / 1px);//... and back

$sass-pink: #c69;
$main-theme-color: $sass-pink;

//lists (~arrays); elements of different types
$font-stack: ('Helvetica', 'Arial', sans-serif);
$font-stack: (
    'Helvetica',
    'Arial',
    sans-serif,
);
//adding items to lists using the respective API
$shadows: (0 42px 13.37px hotpink);
$shadow: gray;
$shadows: append($shadows, $shadow, comma);

//maps
$breakpoints: (
    'small': 767px,
    'medium': 992px,
    'large': 1200px,
);

//to debug Sass maps
//@mixin debug-map($map) {
//    @at-root {
//        @debug-map {
//            __toString__: inspect($map);
//            __length__: length($map);
//            __depth__: if(function-exists('map-depth'), map-depth($map), null);
//            __keys__: map-keys($map);
//            __properties__ {
//                @each $key, $value in $map {
//                    #{'(' + type-of($value) + ') ' + $key}: inspect($value);
//                }
//            }
//        }
//    }
//}

/// Compute the maximum depth of a map
/// @param {Map} $map
/// @return {Number} max depth of `$map`
@function map-depth($map) {
    $level: 1;

    @each $key, $value in $map {
        @if type-of($value) == 'map' {
            $level: max(map-depth($value) + 1, $level);
        }
    }

    @return $level;
}

@warn 'You can\'t do that.';
@warn "You can't do that.";

.foo {
    display: block;
    overflow: hidden;
    padding: 0 1em;
    background-image: url('../images/gulp-tiny.png');
    margin: 2em;
    opacity: 0.5;
    width: (100% / 3);
}

/**
 * 1. Magic number(to be avoided or, if not possible, commented). This value is the lowest I could find to align the top of
 * `.foo` with its parent. Ideally, we should fix it properly.
 */
.foo {
    top: 0.327em; /* 1 */
}

.foo {
    //color values formats, in order of preference
    color: red;
    color: hsl(300, 100%, 100%);
    color: rgba(0, 0, 0, 0.1);
    color: #F00;
}

//for colors use mix()/scale-color() functions instead of lighten()/darken() functions

// Mixins using mix(), also available in the Compass library
/// Slightly lighten a color
/// @access public
/// @param {Color} $color - color to tint
/// @param {Number} $percentage - percentage of `$color` in returned color
/// @return {Color}
@function tint($color, $percentage) {
    @return mix(white, $color, $percentage);
}

/// Slightly darken a color
/// @access public
/// @param {Color} $color - color to shade
/// @param {Number} $percentage - percentage of `$color` in returned color
/// @return {Color}
@function shade($color, $percentage) {
    @return mix(black, $color, $percentage);
}


.foo, .foo-bar,//related selectors on the same line
.baz {
    display: block;
    overflow: hidden;
    margin: 0 auto;
}

//ruleset anatomy
.foo, .foo-bar,
.baz {
    $length: 42em;//local variables being declared before any declarations, then spaced from declarations by a new line;

    //@include ellipsis;//mixin calls with no @content coming before any declaration;
    //@include size($length);
    display: block;
    overflow: hidden;
    margin: 0 auto;

    &:hover {//nested selectors always coming after a new line;
        color: red;
    }

    //@include respond-to('small') {//mixin calls with @content coming after any nested selector;
    //    overflow: visible;
    //}
}//no new line before a closing brace (}).


//ordering properties by type(use https://github.com/csscomb/csscomb.js), alphabetically, concentric(according to the box-model, from outside to inside), or random
//At some point, the risk of losing track and not being able to understand what’s going on anymore is so high that it is not worth it.
//To prevent such a situation, we avoid selector nesting as much as possible. However, there are obviously a few exceptions to this rule.
.foo {
    height: 100px;
    width: 100px;
    overflow: hidden;
    position: absolute;
    bottom: 0;
    right: 0;
    background: black;
    color: white;
    font-weight: bold;
    font-size: 1.5em;
}


//nesting selectors; while it might be anecdotal, generating new selectors from the current selector reference (&) makes those selectors unsearchable in the codebase since they do not exist per se.
.foo {
    .bar {
        &:hover {
            color: red;
        }
    }
}

.foo {
    &-bar {
        color: red;
    }
}

//it is allowed and even recommended to nest pseudo-classes and pseudo-elements within the initial selector.
.foo {
    color: red;

    &:hover {
        color: green;
    }

    &::before {
        content: 'pseudo-element';
    }
}
//also, when using component-agnostic state classes such as .is-active, it is perfectly fine to nest it under the component’s selector to keep things tidy.
.foo {
    // ...

    &.is-active {
        font-weight: bold;
    }
}
//last but not least, when styling an element because it happens to be contained within another specific element, it is also fine to use nesting to keep everything about the component at the same place.
.foo {
    // ...

    .no-opacity & {
        display: none;
    }
}
//...equivalent with...
/// Helper mixin to provide simple API to selector nesting
/// @param {String} $selector - Selector
@mixin when-inside($selector) {
    #{$selector} & {
        @content;
    }
}
.foo {
    // ...

    @include when-inside('.no-opacity') {
        display: none;
    }
}


//Naming convention: Regarding variables, functions and mixins, we stick to something very CSS-y: lowercase hyphen-delimited
$vertical-rhythm-baseline: 1.5rem;
@mixin size($width, $height: $width) {
    // ...
}
@function opposite-direction($direction) {
    // ...
}
$CSS_POSITIONS: (top, right, bottom, left, center);//constants


//namespacing, for reusable modules
$su-configuration: ( red );
@function su-rainbow($unicorn) {
    // ...
}


//Commenting
//commenting takes very little time when done seamlessly along with the code so do it at the right time. Coming back at a piece of code to comment it is not only completely unrealistic but also extremely annoying.
/**
 * Helper class to truncate and add ellipsis to a string too long for it to fit
 * on a single line.
 * 1. Prevent content from wrapping, forcing it on a single line.
 * 2. Add ellipsis at the end of the line.
 */
.ellipsis {
    white-space: nowrap; /* 1 */
    text-overflow: ellipsis; /* 2 */
    overflow: hidden;
}

//When commenting a Sass-specific section, use Sass inline comments instead of a C-style block. This makes the comment invisible in the output, even in expanded mode during development.
// Add current module to the list of imported modules.
// `!global` flag is required so it actually updates the global variable.
//$imported-modules: append($imported-modules, $module) !global;


//Documenting, using SassDoc(http://sassdoc.com/) (Note: three slashes (/) required.); being able to generate an HTML version of the API documentation by using any of the SassDoc endpoints (CLI tool, Grunt, Gulp, Broccoli, Node…)

/// Vertical rhythm baseline used all over the code base.
/// @type Length
$vertical-rhythm-baseline: 1.5rem;

/// Mixin helping defining both `width` and `height` simultaneously.
///
/// @author Hugo Giraudel
///
/// @access public
///
/// @param {Length} $width - Element’s `width`
/// @param {Length} $height ($width) - Element’s `height`
///
/// @example scss - Usage
///   .foo {
///     @include size(10em);
///   }
///
///   .bar {
///     @include size(100%, 10em);
///   }
///
/// @example css - CSS output
///   .foo {
///     width: 10em;
///     height: 10em;
///   }
///
///   .bar {
///     width: 100%;
///     height: 10em;
///   }
@mixin size($width, $height: $width) {
    width: $width;
    height: $height;
}


//Project architecture; Thanks to Sass’s overload of the @import directive, it is perfectly safe (and actually recommended) to use as many files as necessary in development, all compiled into a single stylesheet when going to production.
//On top of that, I cannot stress enough the need for folders, even on small scale projects. At home, you don’t drop every sheet of paper into the same box. You use folders; one for the house/flat, one for the bank, one for bills, and so on. There is no reason to do otherwise when structuring a CSS project. Split the codebase into meaningful separated folders so it is easy to find stuff later when you have to come back to the code. (see the model from https://smacss.com/)
//Note: I have learnt that architecture is most of the time very specific to the project. Feel free to discard completely or adapt the proposed solution so that you deal with a system that suits your needs.
//Most of any interface can be thought of as little components and I highly recommend you stick to this paradigm. This will not only shorten the amount of CSS needed for the whole project, but also happens to be much easier to maintain than a chaotic mess where everything is flustered.

//The 7-1 Pattern(7 folders, 1 file)


//RWD; naming breakpoints
//I think it is safe to say that media queries should not be tied to specific devices. For instance, this is definitely a bad idea to try targeting iPads or Blackberry phones specifically. Media queries should take care of a range of screen sizes, until the design breaks and the next media query takes over.
//For the same reasons, breakpoints should not be named after devices but something more general. Especially since some phones are now bigger than tablets, some tablets bigger than some tiny screen computers, and so on…
$breakpoints: (
    'medium': (min-width: 800px),//not 'tablet'
    'large': (min-width: 1000px),//not 'computer'
    'huge': (min-width: 1200px),//not 'tv'
);


//Breakpoint manager, to use the breakpoints set above in media queries
//Obviously, this is a fairly simplistic breakpoint manager. If you need a slightly more permissive one, may I recommend you do not reinvent the wheel and use something that has been proven effective such as Sass-MQ, Breakpoint or include-media.

/// Responsive manager.
/// @access public
/// @param {String} $breakpoint - Breakpoint
/// @requires $breakpoints
@mixin respond-to($breakpoint) {
    $raw-query: map-get($breakpoints, $breakpoint);

    @if $raw-query {
        $query: if(type-of($raw-query) == 'string', unquote($raw-query), inspect($raw-query));

        @media #{$query} {
            @content;
        }
    } @else {
        @error 'No value found for `#{$breakpoint}`. '
         + 'Please make sure it is defined in `$breakpoints` map.';
    }
}
//usage
@include respond-to('medium') {
    .foo {
        display: none; /* medium */
    }
}


//Where should the media queries be written? Inside selectors.
//You might hear that this convention results in duplicated media queries in the CSS output. That is definitely true. Although, tests have been made and the final word is that it doesn’t matter once Gzip (or any equivalent) has done its thing
//Now, if you really are concerned about duplicated media queries, you can still use a tool to merge them such as this gem(https://github.com/aaronjensen/sass-media_query_combiner) however I feel like I have to warn you against possible side-effects of moving CSS code around. You are not without knowing that source order is important.
.foo {
    color: red;

    @include respond-to('medium') {
        color: blue;
    }
}


//Variables, when:
//the value is repeated at least twice;
//the value is likely to be updated at least once;
//all occurrences of the value are tied to the variable (i.e. not by coincidence).
//Basically, there is no point declaring a variable that will never be updated or that is only being used at a single place.

//Variable scoping
//The docs talk about global variable shadowing.
//When declaring a variable that already exists on the global scope in an inner scope (selector, function, mixin…), the local variable is said to be shadowing the global one.
//Basically, it overrides it just for the local scope.

// Initialize a global variable at root level.
$variable: 'initial value';
// Create a mixin that overrides that global variable.
@mixin global-variable-overriding {
    $variable: 'mixin value' !global;
}
.local-scope::before {
    // Create a local variable that shadows the global one.
    $variable: 'local value';

    // Include the mixin: it overrides the global variable.
    @include global-variable-overriding;

    // Print the variable’s value.
    // It is the **local** one, since it shadows the global one.
    content: $variable;
}
// Print the variable in another selector that does no shadowing.
// It is the **global** one, as expected.
.other-local-scope::before {
    content: $variable;
}


//The !default flag
//When building a library, a framework, a grid system or any piece of Sass that is intended to be distributed and used by external developers, all configuration variables should be defined with the !default flag so they can be overwritten.
$baseline: 1em !default;

//Thanks to this, a developer can define his own $baseline variable before importing your library without seeing his value redefined.
// Developer’s own variable
$baseline: 2em;
// Your library declaring `$baseline`
//@import 'your-library';//where "$baseline: 1em !default;" code lives
// $baseline == 2em;


//The !global flag
//The !global flag should only be used when overriding a global variable from a local scope. When defining a variable at root level, the !global flag should be omitted.

//Multiple Variables Or Maps
//There are advantages of using maps rather than multiple distinct variables. The main one is the ability to loop over a map, which is not possible with distinct variables.
/// Z-indexes map, gathering all Z layers of the application
/// @access private
/// @type Map
/// @prop {String} key - Layer's name
/// @prop {Number} value - Z value mapped to the key
$z-indexes: (
    'modal': 5000,
    'dropdown': 4000,
    'default': 1,
    'below': -1,
);

/// Get a z-index value from a layer name
/// @access public
/// @param {String} $layer - Layer’s name
/// @return {Number}
/// @require $z-indexes
@function z($layer) {
    @return map-get($z-indexes, $layer);
}


//Extend
//Makes it possible to tell Sass to style an element A exactly as though it also matched selector B. Needless to say this can end up being a valuable ally when writing modular CSS.
//However I feel like I must warn you against this feature. As clever as it is, @extend still is a tricky concept that might do more harm than good, especially when poorly used. The thing is, when extending a selector, you have little to no way to answer these questions without having an in-depth knowledge of the whole codebase:
//where is my current selector going to be appended?
//am I likely to be causing undesired side-effects?
//how large is the CSS generated by this single extend?
//
//There are scenarios where extending selectors might be helpful and worthwhile. Yet, always keep in mind those rules so you don’t get yourself into trouble:
//Use extend from within a module, not across different modules.
//Use extend on placeholders exclusively, not on actual selectors.
//Make sure the placeholder you extend is present as little as possible in the stylesheet.
//If you are going to use extend, let me also remind you that it does not play well with @media blocks. As you may know, Sass is unable to extend an outer selector from within a media query. When doing so, the compiler simply crashes, telling you that you cannot do such a thing. Not great. Especially since media queries are almost all we do know. You may only @extend selectors within the same directive.
//Note: It is often said that @extend helps with the file size since it combines selectors rather than duplicated properties. That is true, however the difference is negligible once Gzip has done its compression. That being said, if you cannot use Gzip (or any equivalent) then switching to a @extend approach might not be that bad as long as you know what you are doing.


//Mixins
//They can contain full CSS rules and pretty much everything that is allowed anywhere in a Sass document. They can even take arguments, just like functions. Needless to say, the possibilities are endless.
//It might be tempting to build extremely powerful mixins with massive amounts of logic. It’s called over-engineering and most developers suffer from it. Don’t over think your code, and above all keep it simple. If a mixin ends up being longer than 20 lines or so, then it should be either split into smaller chunks or completely revised.
//That being said, mixins are extremely useful and you should be using some. The rule of thumb is that if you happen to spot a group of CSS properties that always appear together for a reason (i.e. not a coincidence), you can put them in a mixin instead.

/// Helper to clear inner floats
/// @author Nicolas Gallagher
/// @link http://nicolasgallagher.com/micro-clearfix-hack/ Micro Clearfix
@mixin clearfix {
    &::after {
        content: '';
        display: table;
        clear: both;
    }
}

/// Helper to size an element
/// @author Hugo Giraudel
/// @param {Length} $width
/// @param {Length} $height
@mixin size($width, $height: $width) {
    width: $width;
    height: $height;
}



//Arguments List
//When dealing with an unknown number of arguments in a mixin, always use an arglist rather than a list. Think of arglist as the 8th hidden undocumented data type from Sass that is implicitly used when passing an arbitrary number of arguments to a mixin or a function whose signature contains ...
@mixin shadows($shadows...) {
    // type-of($shadows) == 'arglist'
    // ...
}

//Sass is actually pretty clever with mixins and function declarations, so much so that you can actually pass a list or a map as an arglist to a function/mixin so that it gets parsed as a series of arguments.
$params: (true, 42, 'kittens');
@include shadows($params...);
//...or...
$params: (
    'c': 'kittens',
    'a': true,
    'b': 42,
);
@include shadows($params...);


//Mixins and Vendor Prefixes
//http://sass-guidelin.es/#mixins-and-vendor-prefixes
